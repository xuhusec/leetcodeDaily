### [2262.Total-Appeal-of-A-String](https://leetcode.com/problems/total-appeal-of-a-string/)

#### Solution 1: Greedy

A brute force solution would be iterate over all possible substrings and get the appeal sum one by one. A little improvement would be once it reach 26 we can stop as the string only contains with lower case english characters. However, it is time-consuming. To iterate over all substrings would be O(n<sup>2</sup>) and iterate the substring for appeal sum would be O(n).  1 <= n <= 10<suo>5</sup>. It would exceed the time limits.

So we need another method. Instead of check substring. We can think reversely. We can check how many substrings a character can attribute its appeal. The sum of that over all characters is the answer we want. If we just consider there is no duplicate for a character meaning there is no other same character in the subtring. The number of substring would be (cur position - previous position) * (next position - cur position). We do not add -1 for both, which would be (cur position - previous position - 1), (next position - cur position - 1) , because taking no prefix and no suffix are also valid. For example, we have "abc". For 'b', "ab", "b", "bc" are all valid. However, that does not count the string with same characters. "abca" also contains appeal of "a" but it is missed in previous equations. The solution is easy. We can make sure only one "a" contains "abca". So we can either let the first 'a' count it or the last 'a' count it. I chose the first 'a'. That means for the first 'a' we can have "abca". But for the second one we only have "bca" as the longest prefix. Let us make it more general,  (cur position - previous position) * (string length - cur position). It is actually simplier than previous equation be cause we only need to keep track the previous position.

So, we can have an array to record the last position of each character. We can initialize it to -1 to make sure (cur position - prev position) is correct to count all the characters before a character without duplicates. Each round,  (cur position - previous position) * (string length - cur position) is added to the answer and prevous position is updated.
