### [1856.Maximum-Subarray-Min-Product](https://leetcode.com/problems/maximum-subarray-min-product/)

#### Solution 1: Monotonic Stack

A brute force solution is to list all the possible sub arrays and find the minimum of each. It would be O(n<sup>3</sup>) (list all the sub arrays O(n<sup>2</sup>); iterate over each subarray O(n) for sum and locating minimum). A better solution wouild be fix the start and keep track the minimum ams sum during the process of expanding the end. It is still  O(n<sup>2</sup>). It would exceed the time limit.

To reduce the time complexity, we can think reversely. Instead of list all the sub arrays. For each element, we can find out all the sub arrays take it as the minimum element. However, find and an element and expand to two ends is still O(n<sup>2</sup>) especially when all the element is the same. The question become how to efficiently locate the last element smaller than the current element and the the next element smaller than the current element. It can be done with monotic stack. After locating the two boundaries, we need to find the max range sum between them including the min element. As every element in the array is > 1, the max range sum comes from the subarray from left boundary + 1 and right boundary - 1. To effeciently get that range, we can use prefix sum.

We can maintain a monotonic increasing stack. The element is the index of the element but the stack is about the value of corresponding index not the index itself. Why do we keep the indices instead of the value directly? That is because we need to calculate the range sum from the prefix sum array.

Each time, we visit a new element, the element in the stack that is greater than the new element should be taken out. The new element is the next smaller element of the token out element. How about the previous smaller element? It is a monotonic stack. So every element before the taken out element is smaller than the taken out element. So the previous element is the stack is the index of previous samller element. So, the smallest element between the previous smaller element and the next smaller element is the one we just taken out. We also have the two indices for the previous smaller element and the next smaller element (we iterate over index the current index we investigate is the index of the next smaller element). So the range sum is (prefixSum[next smaller element index - 1] - prefixSum[previous samller element index]). For index 0, there is no previous samller element. To fix it, I add -1 to the stack and does not pop it out. And add a leading zero in prefix sum array for this item. After adding this dummy element in prefix sum array. We have (prefixSum[i] - prefixSum[p + 1]) where i is the current index of element (next samller element) in the array and p is the index of previous smaller element.

You might notice there could be duplicates in the array. Actually both `arr[stack.peek()] >= curVal` and `arr[stack.peek()] > curVal` work, the previous one use the later of the equal element to consider the prefix including equal element and the later one take the first appear element to count the suffix including the equal element. That is because we need to clear the stack after the above iteration And the sum to the next smaller element is the sum of the whole array. 

We need to handle the smallest element case. So -1 was pushed to the stack first as appending a very small element so that it become a boundaries for the sub array with smallest element in the array. And we have `stack.size() > 1` to make sure it is not popped out. 

Please note the value is very large, we need to use long. Please only take modulo at the end because we need to compare different product.