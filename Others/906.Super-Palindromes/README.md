### [906. Super Palindromes](https://leetcode.com/problems/super-palindromes/)

#### Solution 1: Brute Force

Please note the super palindromes are square of another palindromes. We have two ways to find super palindromes. One way is to iterate over all palindromes and check if their square roots are also palindromes. The other is to iterate palindromes as square root and check if their squares are palindrome. It is hard to find the later is better. That is because we are given a range for supper palindromes. It is at level 10<sup>18</sup>. We can construct the palindrome by iterate its half. That means 10<sup>9</sup>. It will timeout. In constrast, iterate over the square root, it would be 10<sup>9</sup> and when we iterate its half, it is 10<sup>5</sup>. So the later is better because of the quick growth in square function.

The next step is to find the start point. the square root of the left would be 10<sup>(len - 1)/2</sup> digits and we can estimate the half of it would be 10<sup>(len - 1)/4</sup>. (len - 1)/2 can be obtained by observation. If we have 1 digits, we would start from 1 (10<sup>0</sup>). For 2 digits, we would start from 1 (10<sup>0</sup>). 3 -> 10<sup>1</sup>, 4 -> 10<sup>1</sup> .... The half of it would 10<sup>(len - 1)/4</sup>. when should we stop? we can generate the candidate of supper palindrome and we can stop if it is greater than the right. But there are two ways to generate the candidate. The total length can be odd or it can be even. When the even case exceeded, the odd may not. So we need to check the odd instead of even. However, the even case can stop within its own. It means when we can the even case, if it is already greater than the right, we do not need to check the even case any more. To do so in a relative clear way, the count function were wrapped in a function. Regardless even or odd, if the candidate greater than the right, we would stop. To keep the order of iterating, in this function, we need define the start and end for the half part. To make sure odd not exceeded any future even case, we can step the boundary within half and half * 10 (exclusive). Clearly the palindrome generated by half * 10 for odd case would exceed the palindrome generated by half for even case. At the end of each loop we can increase half to half * 10 for the next round. It function to drive candidate of super palindrome is also extracted so that we can check in the beginning if the odd candidate exceeded the right.

There are many ways to check if a number is palindrome. We can reverse the number and check if the two number is the same or we can convert it to string and check the character.
```java
    private boolean isPalindrome(long square) {
        long reverse = 0;
        long temp = square;
        while (temp > 0) {
            reverse = reverse * 10 + (temp % 10);
            temp /= 10;
        }
        return reverse == square;
    }
```

```java
    private boolean isPalindrome(long square) {
        String s = String.valueOf(square);
        String r = new StringBuilder().append(s).reverse().toString();
        return s.equals(r);
    }
```